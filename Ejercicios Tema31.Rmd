---
title: "UGR Tema 3"
author: "franmarq@gmail.com"
date: '2022-11-30'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




```{r paquetes}
library(geoR)
library(fields)

```
En primer lugar llemos la data de trabajo

```{r data2}
datany <- read.csv('NY_schools.csv', header = T)
str(datany)
datany2 <- datany[,c(5,29,30)]
str(datany2)

datanygeo <- as.geodata(datany2,coords.col = 2:3,data.col = 1, data.names = NULL)
names(datanygeo)
str(datanygeo)
data(datanygeo)
summary(datanygeo)

#resolver coordendas duplicadas
dup.coords(datanygeo)
datanygeo <- jitterDupCoords(datanygeo, max=0.01)




```

De la data original, tomamos la variables: longitud, latitud y ScoreSatMatematica. Y creamos el conjunto de datos spaciales datanygeo. A continuación generamos graficos que nos describen las caracteríticas principales de los datos.

```{r plots}
plot(datanygeo, trend = "1st", lowess=TRUE)
```
A continuación generamos un gráfico, similar a una imagen donde las ubicaciones se discretizan en una cuadrícula, dado un vector de valores z de la variable resultado (score) asociados con ubicaciones bidimensionales los valores z se codifican como un nivel de color de una escala de color.

```{r plots2}
quilt.plot(datanygeo$coords, datanygeo$data, ny = ,
           ylim = c(-74.2, -73.7),
           xlim = c(40.5, 40.9), xlab = "Easting", ylab = "Northing")

```

 Variogramas empíricos

```{r variogram1}
par(mfrow = c(1, 2), las = 1)

cloud1 <- variog(datanygeo, option = "cloud", max.dist=1)
bin1 <- variog(datanygeo, uvec=seq(0,1,l=11))
plot(cloud1, main = "Estimator clasico")

#plot(bin1, main = "classical estimator")
datanygeo.vario <- variog(datanygeo, max.dist = 1)

#plot(datanygeo.vario)
datanygeo.variot <- variog(datanygeo, trend = "1st",  max.dist = 1)
plot(datanygeo.variot)

```

Adicionalmente, los puntos de las nubes de variograma se pueden agrupar en clases de distancias ("contenedores") y mostrarse con un diagrama de caja para cada contenedor.


```{r variogram2}
bin1 <- variog(datanygeo,uvec = seq(0,1,l=11), bin.cloud = T)
par(mfrow = c(1,2))
plot(bin1, bin.cloud = T, main = "Estimator clasico")

```

Los variogramas teóricos y empíricos se pueden trazar y comparar visualmente. Por ejemplo, la siguiente figura muestra el modelo de variograma teórico utilizado para simular los datos 'datany' y el variograma estimados suavizado.

```{r calcvariog}
bin1 <- variog(datanygeo, uvec = seq(0,1,l=100))
plot(bin1)
lines.variomodel(cov.model = "exp", cov.pars = c(8000,0.3), nugget = 0, max.dist = 1,  lwd = 3)
smooth <- variog(datanygeo, option = "smooth", max.dist = 1, n.points = 400, kernel = "normal", band = 0.15)
lines(smooth, type ="l", lty = 2)
legend(0.01, 10000, c("empirico", "suavizado"), lty = c(1,1,2), lwd = c(1,3,1))

```



Ajuste de Variogramas teoricos
Minimos cuadrados

a continuación se muestra como podemos agregar una línea con un modelo de variograma a una gráfica de variograma.

```{r ajuste0}
plot(variog(datanygeo, max.dist=1))
lines.variomodel(cov.model="exp", cov.pars=c(8000,.3), nug=0, max.dist=1)
lines.variomodel(cov.model="mat", cov.pars=c(8000,.2), nug=0.1, kappa=1,max.dist=1, lty=2)
lines.variomodel(cov.model="sph", cov.pars=c(8000,.8), nug=0.1,max.dist=1, lwd=2)

```


```{r ajustes}
# sin tendencia espacial
datanygeo.vfit.exp <- variofit(datanygeo.vario)
datanygeo.vfit.mat1.5  <- variofit(datanygeo.vario, kappa = 1.5)
datanygeo.vfit.sph  <- variofit(datanygeo.vario, cov.model = "sph")

# con tendencia lineal
#datanygeo.vtfit.exp <- variofit(datanygeo.variot)
#datanygeo.vtfit.mat1.5  <- variofit(datanygeo.variot, kappa = 1.5)
#datanygeo.vtfit.sph  <- variofit(datanygeo.variot, cov.model = "sph")
```

Graficamos el resultado del ajuste de estos modelos

```{r plotajuste}

#par(mfrow = c(1, 2))
plot(datanygeo.vario)
lines(datanygeo.vfit.exp); lines(datanygeo.vfit.mat1.5, col = 2); lines(datanygeo.vfit.sph, col = 4)
#plot(datanygeo.variot)
#lines(datanygeo.vtfit.exp); lines(datanygeo.vtfit.mat1.5, col = 2); lines(datanygeo.vtfit.sph, col = 4)
```

Mapa de Interpolacion

consideremos la predicción en cuatro ubicaciones etiquetadas con 1, 2, 3, 4 e indicadas a continuación.

```{r interpol}
loci <- matrix(c(40, 40.1, 40.2, 40.3, 40.7, 40.8, 40.9, 41), ncol=2)

kc4 <- krige.conv(datanygeo, locations = loci, krige = krige.control(obj.m = datanygeo.vfit.exp))
print("Valores predichos")
kc4$predict
print("Varianza kriging")
kc4$krige.var

```
